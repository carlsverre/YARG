package yarg{  import flash.display.MovieClip;  import com.carlsverre.yagf.KeyManager;  import flash.geom.Point;  public class Runner extends MovieClip  {    private static const STATE_IDLE:String = "idle";    private static const STATE_JUMP:String = "jump";    private static const STATE_RUNNING:String = "running";        private var state:String = STATE_IDLE;    private var jumping:Boolean = false;        // Physics    private var mass:Number;    private var radius:Number;        public var Acceleration:Point;    public var MaxVelocity:Point;        private var velocity:Point;    private var position:Point;    private var lastPosition:Point;        public var Gravity:Point;    public var Friction:Point;        private function changeState(newState:String):void {      if(state != newState) {        state = newState;        gotoAndPlay(state);      }    }        public function Reset(x:int, y:int):void {      position = new Point(x,y);      lastPosition = new Point(x, y);            radius = width / 2;      mass = radius * 4;            velocity = new Point(0,0);            Acceleration = new Point(0, 0);      MaxVelocity = new Point(0, 0);      Gravity = new Point(0, 0);      Friction = new Point(0, 0);    }        public function CollideWith(collision:Object):void {      var angle:Number = collision.angle;      var overlap:int = collision.overlapping.length;            trace("---");      trace("collision angle: ",angle);      trace("collision overlap: ", overlap);            if (collision.angle < 2.0943951 && collision.angle > 1.04719755) {        trace("hit floor");        jumping = false;      }            var sin:Number = Math.sin(angle);      var cos:Number = Math.cos(angle);            var vx0:Number = velocity.x * cos + velocity.y * sin;      var vy0:Number = velocity.y * cos - velocity.x * sin;            vx0 = ((mass - 50) * vx0) / (mass + 50);      velocity.x = vx0 * cos - vy0 * sin;      velocity.y = vy0 * cos + vx0 * sin;            velocity.x -= cos * overlap / radius;      velocity.y -= sin * overlap / radius;            position.x += velocity.x;      position.y += velocity.y;    }        public function Update(delta:Number):void {      lastPosition.x = position.x;      lastPosition.y = position.y;            if(KeyManager.ActionPressed("right")) {        velocity.x += Acceleration.x * delta;      }      if(KeyManager.ActionPressed("left")) {        velocity.x -= Acceleration.x * delta;      }      if (KeyManager.ActionPressed("jump") && !jumping) {        velocity.y = -Acceleration.y;        jumping = true;      }            velocity.x += Gravity.x;      velocity.y += Gravity.y;      //velocity.y *= Friction.y;      //velocity.x *= Friction.x;            velocity.x = (velocity.x > MaxVelocity.x) ? MaxVelocity.x : velocity.x;      velocity.y = (velocity.y > MaxVelocity.y) ? MaxVelocity.y : velocity.y;            position.x += velocity.x;      position.y += velocity.y;            // update state      if(velocity.y < 0) changeState(STATE_JUMP);      else if(velocity.x != 0) changeState(STATE_RUNNING);      else changeState(STATE_IDLE);            // update direction      if(velocity.x > 0) scaleX = 1;      else scaleX = -1;    }        public function Draw():void {      x = position.x;      y = position.y;    }      }}